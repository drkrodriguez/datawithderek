{
  "hash": "45c72d5d9728373fa035e0a4c0593189",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Starting Linear Programming in Python\"\nauthor: \"Derek Rodriguez\"\ndate: \"2024-11-28\"\nimage: \"python-linprog-thumbnail.png\"\ncategories: [Python, Optimization, Linear Programming, Learn With Me]\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\nIn this post, I will solve a simple linear programming (LP) problem using three Python packages: [Google's ORTools](https://developers.google.com/optimization), [PuLP](https://coin-or.github.io/pulp/index.html) and [SciPy](https://docs.scipy.org/doc/scipy/reference/optimize.html).\n\nThis is the first time I am trying optimization in Python. My previous experience with solver software has been with some commercial solvers or MS Excel while I was in college, and using supply chain modeling software at work. For my first try, I am being guided by the posts of [Mirko Stojiljković from Real Python](https://realpython.com/linear-programming-python/), and [Maximme Labonne from Towards Data Science](https://towardsdatascience.com/introduction-to-linear-programming-in-python-9261e7eb44b).\n\nSince I will be focusing on the packages, I won't be explaining Linear or Mathematical Programming in this post, and will go straight to the problem, the mathematical formulation, and then the building and optimizing of the model using the three packages mentioned. Mirko's and Maximme's posts give good overviews, but there are a large number of material online and offline covering linear programming and operations research.\n\n# A Sample Problem\n\nI will be using a single problem to try the three packages. I am taking a review problem from one of my college textbooks. *(Winston, Wayne & Venkataraman. 2003. Introduction to Mathematical Programming. Operations Research: Volume One. Fourth Edition. Brooks/Cole. Thomson Learning)* The chosen problem will be a pure linear programming problem so we will not focus on any integer or binary variables for now.\n\n## A simple profit maximization problem\n\nA company produces tools at two plants and sells them to three customers.The cost of producing 1000 tools at a plant and shipping them to a customer is given in the table below.\n\n| Plant | Customer 1 | Customer 2 | Customer 3 |\n|:-----:|:----------:|:----------:|:----------:|\n|   1   |     60     |     30     |    160     |\n|   2   |    130     |     70     |    170     |\n\nCustomers 1 and 3 pay \\$200 per thousand tools; Customer 2 pays \\$150. To produce 1,000 tools at Plant 1, 200 hours of labor are needed, while 300 hours are needed at Plant 2. A total of 5,500 hours of labor are available are available for use at the two plants. Additional labor hours can be purchased at \\$20 per labor hour. Plant 1 can produce up to 10,000 tools while Plant 2 can produce up to 12,000 tools. Demand by each customer is assumed to be unlimited.\n\n**How many tools should be produced and shipped by each plant to each customer?**\n\n## LP Formulation\n\nI will jump straight into fomulating the problem as an LP model by defining its three major parts: ***the decision variables, the objective funtion, the constraints***.\n\nThe **decision variables** are the unknowns that we want to solve for. In our problem, these are:\n\n\\$ X\\_{ij} =\\$ the number of tools in thousands produced in plant $i$ and shipped to customer $j$ for $i = 1, 2$, and $j = 1, 2, 3$\n\n\\$ L =\\$ additional labor hours to purchase\n\nThe **objective function** is a value that we want to maximize or minimize and is a function of the decision variables. As we have sales and cost figures, we would expect that we want to maximize the profit generated by our decisions:\n\n**Maximize:**\n\n$Z =$ sales from customers + cost to ship to customers + cost of additional labor hours\n\n$Z = 200 \\sum_{i=1}^{2} X_{i1}\\ + 150 \\sum_{i=1}^{2} X_{i2}\\ + 200 \\sum_{i=1}^{2} X_{i3}\\ - \\sum t_{ij}X_{ij} \\ - 20L$ , where $t_{ij}$ is the cost of shipping 1000 units from plant $i$ to customer $j$\n\n$Z = (200-60)X_{11} + (200-130)X_{21} + (150-30)X_{12} + (150-70)X_{22} + (200-160)X_{13} + (200-170)X_{23} - 20L$\n\n$Z = 140X_{11} + 70X_{21} + 120X_{12} + 80X_{22} + 40X_{13} + 30X_{23} - 20L$\n\nThe **constraints** represent the conditions or requirements and limit the values that variables can take.\n\nLabor constraint:\n\n$200 (X_{11}+X_{12}+X_{13}) + 300(X_{21}+X_{22}+X_{23}) \\leq 5500 + L$\n\nProduction constraints:\n\n$X_{11} + X_{12} + X_{13} \\leq 10$\n\n$X_{21} + X_{22} + X_{23} \\leq 12$\n\nNonnegativity: *All variables are nonnegative*\n\n$X_{ij} \\geq 0$ ; for every plant $i$ and customer $j$\n\n$L \\geq 0$\n\n# Solving using SciPy\n\nI will follow the steps outlined in [Mirko's post](https://realpython.com/linear-programming-python/) to solve the above problem using [SciPy](https://docs.scipy.org/doc/scipy/reference/optimize.html). The first step is to load the [`linprog()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog) from SciPy's Optimize module.\n\n::: {#879459b6 .cell execution_count=1}\n``` {.python .cell-code}\nfrom scipy.optimize import linprog\n```\n:::\n\n\n`linprog()` only works with minimization problems that don't have constraints with greater than inequalities. (i.e., all variables on the left side are greater than or equal to a constant on the right side) Our problem is currently a maximization type, but we can solve this by negating the whole expression to turn it into a minimization problem.\n\n**Maximize:**\n\n$Z = 140X_{11} + 70X_{21} + 120X_{12} + 80X_{22} + 40X_{13} + 30X_{23} - 20L$\n\nis equivalent to, **Minimize:**\n\n$-Z = 20L -140X_{11} - 70X_{21} - 120X_{12} - 80X_{22} - 40X_{13} - 30X_{23}$\n\n`linprog()` requires a mandatory input `c` which is a 1D array denoting the objective function. The following are some of its optional arguments:\n\n-   `A_ub` - a 2D array for the left hand side of inequality constraints\n\n-   `b_ub` - a 1D array for the right hand side of inequality constraints\n\n-   `A_eq` - a 2D array for the left hand side of equality constraints\n\n-   `b_eq` - a 1D array for the right hand side of equality constraints\n\n-   `bounds` - a sequence of tuples denoting the minimum and maximum value of each variable. If only one tuple is defined, then the bounds apply to all variables\n\n-   `method` - the algorithm used to solver the problem. The default is `'highs'` and can also be set to `'highs-ds'` and `'highs-ipm'`. Other (legacy) methods are available at the moment but will soon be deprecated\n\n-   `callback` - callback function that will be run once per iteration of the algorithm\n\n-   `integrality` - a 1D array which specifies the integrality of each variable. This accepts a value of `0`, `1`, `2`, `3` for each variable. `0` is the default and specifies that there is no integrality constraint, while `1` specifies that the variable must take an integer value. A value of `2` or `3` indicates that the variable is either continuous or integral within bounds, or is zero. This argument is only accepted by the `'highs'` method.\n\nBased on this, we can define variables to be used as inputs to the `c` and the first five arguments. When building the input arrays or lists, the order of the variables should be consistent. For our case, we will use the following order, which is how the variables appear in the minimization objective function:\n\n$L, X_{11} , X_{21} , X_{12} , X_{22} , X_{13} , X_{23}$\n\n::: {#247ad274 .cell execution_count=2}\n``` {.python .cell-code}\nobj = [20, -140, -70, -120, -80, -40, -30]\n\nlhs_ineq = [[-1, 200, 300, 200, 300, 200, 300],  # Labor constraint left side\n            [0, 1, 0, 1, 0, 1, 0],  # Plant 1 production constraint left side\n            [0, 0, 1, 0, 1, 0, 1]]  # Plant 2 production constraint left side\n\nrhs_ineq = [5500,  # Labor constraint right side\n            10,  # Plant 1 constraint right side\n            12]  # Plant 2 constraint right side\n\n# no equality constraints\n\nbnd = [(0, None)]\n```\n:::\n\n\nWe can pass these into the arguments of `linprog()` to solve the problem. The function returns an object of type `scipy.optimize.OptimizeResult` that gives the optimum values of the decision variables in the field `x` and the minimum value of the objective function in the field `fun`.\n\n::: {#6d9a03e2 .cell execution_count=3}\n``` {.python .cell-code}\nopt = linprog(c=obj, A_ub=lhs_ineq, b_ub=rhs_ineq, bounds=bnd)\n\nopt\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n        message: Optimization terminated successfully. (HiGHS Status 7: Optimal)\n        success: True\n         status: 0\n            fun: -2333.333333333333\n              x: [ 0.000e+00  1.000e+01  0.000e+00  0.000e+00  1.167e+01\n                   0.000e+00  0.000e+00]\n            nit: 1\n          lower:  residual: [ 0.000e+00  1.000e+01  0.000e+00  0.000e+00\n                              1.167e+01  0.000e+00  0.000e+00]\n                 marginals: [ 1.973e+01  0.000e+00  1.000e+01  2.000e+01\n                              0.000e+00  1.000e+02  5.000e+01]\n          upper:  residual: [       inf        inf        inf        inf\n                                    inf        inf        inf]\n                 marginals: [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00\n                              0.000e+00  0.000e+00  0.000e+00]\n          eqlin:  residual: []\n                 marginals: []\n        ineqlin:  residual: [ 0.000e+00  0.000e+00  3.333e-01]\n                 marginals: [-2.667e-01 -8.667e+01 -0.000e+00]\n mip_node_count: 0\n mip_dual_bound: 0.0\n        mip_gap: 0.0\n```\n:::\n:::\n\n\nThe solver was able to find the optimal value of \\$2,333 (`fun`) achieved by shipping 10000 pcs from Plant 1 to Customer 1 and 11667 pieces from Plant 2 to Customer 2.\n\n# Solving using PuLP\n\n[PuLP](https://coin-or.github.io/pulp/index.html) is another package for optimization and is able to call external solvers to solve the model. I will again use [Mirko's post](https://realpython.com/linear-programming-python/) for the steps.\n\nWe first import the functions that we will use from the pulp package.\n\n::: {#dec40e7e .cell execution_count=4}\n``` {.python .cell-code}\nfrom pulp import LpMaximize, LpProblem, LpStatus, lpSum, LpVariable\n```\n:::\n\n\nThe first step is creating an object that represents the LP model using `LpProblem()` The sense argument specifies the objective of the problem which could either be `LpMinimize` (default, minimization) or `LpMaximize`. (maximization)\n\n::: {#e3c8e4b5 .cell execution_count=5}\n``` {.python .cell-code}\nmodel = LpProblem(name=\"sample-problem\", sense=LpMaximize)\n```\n:::\n\n\nThe next step is defining the variables using the function `LpVariable()`. This function has the following arguments, of which only the first is mandatory\n\n-   `name` - name of the variable\n\n-   `lowBound` , `upBound` - minimum and maxumum value of the variable. Default is negative infinity and positive infinity\n\n-   `cat` - The category of the variable. The default is `'Continuous'`, but can also be set as `'Integer'` or `'Binary'`\n\n-   `e` - used for column-based modeling (we will not discuss further for this post)\n\nWe then define the 7 decision variables with separate calls of `LpVariable()`:\n\n::: {#70052df1 .cell execution_count=6}\n``` {.python .cell-code}\nL = LpVariable(name = \"L\", lowBound = 0)\n\nx11 = LpVariable(name = \"x11\", lowBound = 0)\nx12 = LpVariable(name = \"x12\", lowBound = 0)\nx13 = LpVariable(name = \"x13\", lowBound = 0)\n\nx21 = LpVariable(name = \"x21\", lowBound = 0)\nx22 = LpVariable(name = \"x22\", lowBound = 0)\nx23 = LpVariable(name = \"x23\", lowBound = 0)\n```\n:::\n\n\nIn a nutshell, constraints can be added to the model as inequalities/equalities, and the objective function can be added as an expression. To illustrate:\n\n::: {#132f31ce .cell execution_count=7}\n``` {.python .cell-code}\nprint(type(2*L)) # This is an expression and represents 2 multiplied by L\n\nprint(type(2*L <= 5)) # This is a constraint as it includes an inequality\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pulp.pulp.LpAffineExpression'>\n<class 'pulp.pulp.LpConstraint'>\n```\n:::\n:::\n\n\nWe will add these into the model by simply adding them into `model`. We will be writing them in full, but there are other functions in the package that can be used to construct expressions or constraints.\n\nTo add the (maximization) objective function, we write the following:\n\n::: {#2afad1da .cell execution_count=8}\n``` {.python .cell-code}\nmodel += 140 * x11 + 70 * x21 + 120 * x12 + 80 * x22 + 40 * x13 + 30 * x23 - 20 * L\n```\n:::\n\n\nConstraints are added similarly, but as a tuple which includes a name for each constraint.\n\n::: {#f074bf60 .cell execution_count=9}\n``` {.python .cell-code}\nmodel += (200 * x11 + 200 * x12 + 200 * x13 + 300 * x21 + 300 * x22 + 300 * x21 + 300 * x23 - L <= 5500, \"Labor\")\nmodel += (x11 + x12 + x13 <= 10, \"Plant1_Production\")\nmodel += (x21 + x22 + x23 <= 12, \"Plant2_Production\")\n```\n:::\n\n\nCalling the object displays the model we have defined.\n\n::: {#a0cc3181 .cell execution_count=10}\n``` {.python .cell-code}\nmodel\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nsample-problem:\nMAXIMIZE\n-20*L + 140*x11 + 120*x12 + 40*x13 + 70*x21 + 80*x22 + 30*x23 + 0\nSUBJECT TO\nLabor: - L + 200 x11 + 200 x12 + 200 x13 + 600 x21 + 300 x22 + 300 x23 <= 5500\n\nPlant1_Production: x11 + x12 + x13 <= 10\n\nPlant2_Production: x21 + x22 + x23 <= 12\n\nVARIABLES\nL Continuous\nx11 Continuous\nx12 Continuous\nx13 Continuous\nx21 Continuous\nx22 Continuous\nx23 Continuous\n```\n:::\n:::\n\n\nWe use `.solve()` to solve the model. A `solver` argument can be specified to override the default solver to be used. We use GLPK as the solver for this post.\n\n::: {#8c747624 .cell execution_count=11}\n``` {.python .cell-code}\nfrom pulp import GLPK\nmodel.solve(solver=GLPK(msg=False))\n\nprint(f\"status: {model.status}, {LpStatus[model.status]}\")\n\nprint(f\"objective: {model.objective.value()}\")\n\nfor var in model.variables():\n  print(f\"{var.name}: {var.value()}\")\n\nfor name, constraint in model.constraints.items():\n  print(f\"{name}: {constraint.value()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstatus: 1, Optimal\nobjective: 2333.3360000000002\nL: 0.0\nx11: 10.0\nx12: 0.0\nx13: 0.0\nx21: 0.0\nx22: 11.6667\nx23: 0.0\nLabor: 0.010000000000218279\nPlant1_Production: 0.0\nPlant2_Production: -0.3332999999999995\n```\n:::\n:::\n\n\nThe results show the same objective and decision variable values as SciPy.\n\n# Solving using ORTools\n\nThe last package that we will test out in this post is [Google's ORTools](https://developers.google.com/optimization). I will be using [Maximme's post](https://towardsdatascience.com/introduction-to-linear-programming-in-python-9261e7eb44b) as a guide where he mentions that the package is quite user-friendly and is the highest starred/rated on GitHub. The package also includes libraries specific to vehicle routing and graph problems.\n\n`pywraplp` is the linear programming solver wrapper which interfaces to MIP (mixed integer programming) and linear solvers. We use the code below to import the module and then declare a solver instance for our problem using `Solver()`. We specify GLOP as the engine to be used.\n\n::: {#721e4c45 .cell execution_count=12}\n``` {.python .cell-code}\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver('Maximize profit', pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)\n```\n:::\n\n\nVariables can be added to the model or solver instance by using on of three functions depending on the variable type:\n\n-   `NumVar` - continuous variables\n\n-   `IntVar` - integer variables\n\n-   `BoolVar` - binary variables\n\nThe functions accept the lower-bound, the upper-bound and the variable name as inputs. To specify no upper-bound, we need to use `.infinity()` as a value.\n\nOur model only contains continuous variables so we will just use `NumVar` to declare them. This approach is similar to what was done in PuLP.\n\n::: {#92915d0b .cell execution_count=13}\n``` {.python .cell-code}\nvar_L = solver.NumVar(0, solver.infinity(), 'L')\n\nvar_x11 = solver.NumVar(0, solver.infinity(), 'x11')\nvar_x12 = solver.NumVar(0, solver.infinity(), 'x12')\nvar_x13 = solver.NumVar(0, solver.infinity(), 'x13')\n\nvar_x21 = solver.NumVar(0, solver.infinity(), 'x21')\nvar_x22 = solver.NumVar(0, solver.infinity(), 'x22')\nvar_x23 = solver.NumVar(0, solver.infinity(), 'x23')\n```\n:::\n\n\nWe add constraints using `.Add()` for each constraint and then passing the inequality (or equality) as an argument.\n\n::: {#0e475bbe .cell execution_count=14}\n``` {.python .cell-code}\nsolver.Add(200 * var_x11 + 200 * var_x12 + 200 * var_x13 + 300 * var_x21 + 300 * var_x22 + 300 * var_x21 + 300 * var_x23 - var_L <= 5500)\nsolver.Add(var_x11 + var_x12 + var_x13 <= 10)\nsolver.Add(var_x21 + var_x22 + var_x23 <= 12)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n<ortools.linear_solver.pywraplp.Constraint; proxy of <Swig Object of type 'operations_research::MPConstraint *' at 0x000001FFCB089990> >\n```\n:::\n:::\n\n\nThe objective function can be defined by using `.Maximize()` or `.Minimize()` depending on the problem. We will be using the first one to define the original maxmimization version of the objective.\n\n::: {#ff2c9dac .cell execution_count=15}\n``` {.python .cell-code}\nsolver.Maximize(140 * var_x11 + 70 * var_x21 + 120 * var_x12 + 80 * var_x22 + 40 * var_x13 + 30 * var_x23 - 20 * var_L)\n```\n:::\n\n\nWith the model defined\n\n::: {#93b1938c .cell execution_count=16}\n``` {.python .cell-code}\nstatus = solver.Solve()\nprint('Optimized: ', status == pywraplp.Solver.OPTIMAL)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOptimized:  True\n```\n:::\n:::\n\n\nWe can display the objective value and the decision variables by calling the specific objects in `solver`.\n\n::: {#647d09c3 .cell execution_count=17}\n``` {.python .cell-code}\nprint(f\"Objective value = {solver.Objective().Value():0.1f}\")\nfor i in solver.variables():\n  print(f\"{i} = {i.solution_value():0.1f}\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nObjective value = 2333.3\nL = 0.0\nx11 = 10.0\nx12 = 0.0\nx13 = 0.0\nx21 = 0.0\nx22 = 11.7\nx23 = 0.0\n```\n:::\n:::\n\n\nWe again see that the output is the same as the previous two. The method of defining variables, constraints, and the objective function is very similar to PuLP, but all three methods produced the same results.\n\n# Initial Thoughts\n\nWe have gone through three different ways to solve LP problems in Python. It is too early for me to tell which one is best for me. The last two appear more user-friendly when coding in variables and constraints, but I am not sure how easy they are to use for large-scale problems where you will load the coefficients of the objective function or the constraints from a separate file or spreadsheet.\n\nThis demo is also limited to a very simple linear problem– there are no integer or binary variables. We also did not go through any further analysis (e.g., sensitivity analysis) and these should be considered when choosing a package to use or focus on.\n\nFor now, I have three new packages in my toolset and I will definitely play around and explore some more.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}